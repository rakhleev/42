---
layout: post                                                              
title: Мобильный кодинг с Termux                                   
subtitle: vim, git, gcc на смартфон    
description: Установка и настройка Termux
image: https://termux.com/files/htop_framed.png                                                                                                  
category: coding                                                            
tags:                                                                     
  - coding                                                                 
  - termux
  - android
  - ish
author: rakhleev
---

### Терминал для смартфона

Если с кодом и Си не хочется расставаться, специально для тебя есть отличное приложение - бесплатный эмулятор терминала для _Android_, называется **Termux**.

> **Termux** — бесплатный эмулятор терминала для _Android_, включающий большую коллекцию пакетов операционной системы _Linux_. По умолчанию в Termux установлена минимальная базовая система. _Дополнительные пакеты доступны из диспетчера пакетов_ `pkg`
 
Если вкратце, **Termux** это карманный Линукс, практически со всеми ништяками.

#### Установка **Termux**

Приложение доступно в [Play Store](https://play.google.com/store/apps/details?id=com.termux), но с недавнего времени эта версия не получает обновлений. Подробнее о проблеме на официальном [вики](https://wiki.termux.com/wiki/Termux_Google_Play).

Поэтому:

1. Гуглим **F-Droid** (или переходим по [ссылке](https://www.f-droid.org/)) 
2. Устанавливаем, запускаем и ищем в нем **Termux**

Вообще, на этом этапе можно остановиться, но по какой-то причине с **F-Droid** у меня скачалась старая версия, не совместимая с _10-11-12_ Андроидами. Начиная с 10-й версии _Android_ работают лишь приложения версии выше _0.1хх_.

... 

Так или иначе, если качает старую версию:

1. Находим в том же **F-Droid** его альтернативную оболочку **Aurora Droid** (в любом случае она получше да пошустрей чем стандартная) 
2. Устанавливаем **Aurora Droid** и ставим оттуда **Termux**

... 

Или просто дожидаемся обновления всех репозитариев в **F-Droid**, прокручиваем страничку **Termux** до конца, жмём на _Versions_, выбираем версию посвежее. 

![alt text](https://i.imgur.com/AoyQ5Rv.png "Termux Version")

#### Установка `vim`, `gcc`, `git`

Сначала обновляемся

`pkg update && pkg upgrade -y`

Устанавливаем вим, компилятор и гит. 

`pkg install vim clang git -y`

Вообще, на этом можно закончить статью, так как все уже должно работать. 

... 

`Вуаля`

... 

_Инфа ниже для тех, кто любит заморачиваться._

#### Настройка Vim через `.vimrc`

Как и на компьютере, файл настройки `.vimrc` расположен по адресу:

`~/.vimrc`

Займёмся его настройкой. Откроем файл через редактор текста `nano` или `vim`:

`nano ~/.vimrc` || `vim ~/.vimrc`

Если открыли через сам `vim`, применяем внесенные изменения не выходя из редактора командой во встроенном терминале:

`:source ~/.vimrc`

##### Основные настройки `.vimrc`

![vim settings](https://i.imgur.com/WxxKdJT.png "Vim Settings")

_Увеличение размера истории изменений_
`set undolevels=2048`

_Показать номера строк_
`set number`

_Подсветка синтаксиса_
`syntax on `

_Не использовать своп-файл_
`set noswapfile`

_Перенос целых слов_
`set linebreak`

_Увеличение размера истории команд_ 
`set history=128`

_Перенос длинных строк_
`set wrap`

_Автозамена_ 
`set et`

_Подсвечивать "пустоту" из табов и пробелов в концах строк символом_ `%`.

![alt text](https://i.imgur.com/da2UlTu.png "Highlight tabs and spaces in vim")

`set listchars=tab:>-,trail:%`


##### `.vimrc`: Сворачиваемые блоки кода

Можно прикрутить функцию сворачивания блоков кода, особенно актуально для больших проектов. 

![toggle code blocks in vim](https://i.imgur.com/iRWOs7S.png "toggle_code_blocks")


`set foldenable " включить блоки`
`set foldmethod=syntax " определение блоков на основе синтаксиса файла`
`set foldmethod=indent " определение блоков по отступам`
`set foldcolumn=3 " полоска для управления сворачиванием`
`set foldlevel=1 " Первый уровень вложенности, блоки в блоках остаются закрытыми`
`set foldopen=all " разворачивание блоков по мере приближения к ним курсора`

##### `.vimrc`: Резервные копии, своп-файлы и persistent история изменений

Настроим резервное копирование, упорядочим процесс возникновения swap файлов и сделаем так, чтобы `vim` запоминал все изменения в документах в отдельный файл. В этом случае `u` (_отмена последних внесённых изменений_) в документах работает даже после того как их закрыли и открыли.  

`set directory=~/.vim/dirs/tmp " директория для всех swap файлов`

`set backup " включить бэкап`

`set backupdir=~/.vim/dirs/backups " путь сохранения бэкап файлов`

`set undofile " undo после закрытия-открытия документа`

`set undodir=~/.vim/dirs/undos`

`set viminfo+=n~/.vim/dirs/viminfo`

`" yankring history file`

`let g:yankring_history_dir = '~/.vim/dirs/'
" создать директории если их нет`

`if !isdirectory(&backupdir)`
    `call mkdir(&backupdir, "p")`
`endif`
`if !isdirectory(&directory)
    call mkdir(&directory, "p")`
`endif`
`if !isdirectory(&undodir)
    call mkdir(&undodir, "p")
endif`

#### Оболочка Z shell

> **Z shell, zsh** — одна из современных командных оболочек UNIX, использующаяся непосредственно как интерактивная оболочка, либо как скриптовый интерпретатор. Zsh является расширенным [bourne shell](https://ru.m.wikipedia.org/wiki/Bourne_shell) с большим количеством улучшений. 

##### Bash или Zsh? 

> Оболочка, используемая по умолчанию в большинстве дистрибутивов Linux называется **Bash**. Оболочка **Zsh** по своей сути такая же как и Bash, только намного интереснее. Она поддерживает _интерактивное автодополнение по_ `Tab`, _автоматический поиск файлов, интегрированные регулярные выражения, а также красивые темы._  

Устанавливаем сначала **Zsh** через менеджер пакетов

`pkg install zsh`

Не забываем запустить

`zsh`

##### Установка oh-my-zsh

Вместе с **Zsh** настоятельно рекомендую поставить **[oh-my-zsh](https://ohmyz.sh)**

> Скрипт **oh-my-zsh** реализует множество дополнительных возможностей в `zsh`. Тут можно выбирать различные темы, добавлять плагины, есть различные возможности автодополнения и другое. 

Для установки скопировать и запустить:

`sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"`

#### Настройка оболочки Zsh через файл конфигурации `.zshrc`

Как и файл с настройками вима, файл `.zshrc` лежит в домашней папке. 

Открывем её через `nano` или `vim`:

`nano ~/.zshrc` || `vim ~/.zshrc`

#####  `.zshrc`:  Настройка истории команд

Для удобства я увеличил количество команд которые сохраняются в истории.

_Сохранение истории команд в файл_ `.zhistory` _в домашней_ `~` _папке._
`HISTFILE=~/.zhistory`

_Число команд, сохраняемых в файл истории команд_
`SAVEHIST=5000`

_Число команд, coxpaняeмыx в сеансе_
`HISTSIZE=5000`
`DIRSTACKSIZE=20`

_Дополнение файла истории_
`setopt  APPEND_HISTORY`

_Игнор всех повторов_
`setopt  HIST_IGNORE_ALL_DUPS`

_Игнор лишних пpoбeлов_
`setopt  HIST_IGNORE_SPACE`

_Удаление лишних строк_
`setopt  HIST_REDUCE_BLANKS`

Если планируете использовать **Zsh** как основной шелл, стоит запретить выходить из `zsh` нажатием `Ctrl` - `C`. 

Делается это добавлением следующей строчки:
`setopt  IGNORE_EOF`

##### `.zshrc`: Создание и использование алиасов

> **Alias** (_лат. **alias** — иначе_) может означать:
Короткое, удобное для запоминания имя, использующееся вместо более длинного и сложного имени;

Например, вместо того чтобы вручную прописывать флаги `-Wall -Wextra -Werror` каждый раз при запуске `gcc` для компиляции, можно создать алиас, назвать её к примеру `gccw`, при вводе в терминал алиас будет запускать команду `gcc -Wall -Wextra -Werror`. 

Добавлять их следует в тот же файл `.zshrc`. После внесения изменений, чтобы их задействовать, необходимо прописать в терминале:

`source ~/.zshrc`

###### `.zshrc`: Облегчаем свою жизнь через алиасы

_Так как символ_ `~` _непросто найти на клавиатуре телефона, я повесил команду возврата в домашний каталог на_ `h`. 
`alias h="cd ~"`

_Очистка окна терминала через_ `c`
`alias c="clear"`

_Возврат в предыдущую папку на_ `b`
`alias b="cd .."`

_Команда_ `termux-open` _работает примерно так же как и_ `open` _на маке, т. е. откроет или предложит открыть файл системными средствами._
`alias open="termux-open"`

_Компилятор с флагами_
`alias gccw="gcc -Wall -Wextra -Werror"`

_Полное обновление одной командой_
`alias upd="pkg update && pkg upgrade"`

Иногда я забываю что менеджер пакетов здесь не `apt`, а `pkg`. 

Если пользуетесь _Ubuntu_ или другой _Debian_-подобной системой, чтобы не мучиться лишний раз, рекомендую добавить сразу:
`alias apt="pkg"`

###### `.zshrc`: Алиасы для работы с git

`alias ga='git add'`
`alias gp='git push'`
`alias gl='git log'`
`alias gs='git status'`
`alias gd='git diff'`
`alias gm='git commit -m'`
`alias gb='git branch'`
`alias gc='git clone'`
`alias grm='git rm'`

#### Termux для айфона

Что насчёт яблока? 

На _iOS_ есть чуть менее продвинутый аналог - **[iSH](https://ish.app/)**, ощутимо сырее и недоработаннее если сравнивать с **Termux**. Тем не менее все работает, но придётся подключить внешнюю клавиатуру, разработчики не позаботились об эмуляции кнопок вроде `Ctrl`, `Esc`, без которых даже `nano` не воспользуешься.

Единственная существенная разница - в **Termux** новые пакеты устанавливаются командой `pkg install`, в **iSh** это `apk add`. 

В остальном, в плане использования отличий практически нет, разве что на фоне **Termux**, **iSH** выглядит мягко говоря плохо, медленно и неудобно. Тем не менее, удивителен сам факт существования подобного приложения на _iOS_).
